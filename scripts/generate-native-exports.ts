/**
 * Generate native entry point with explicit exports, excluding unsupported components
 *
 * Usage: npx ts-node --esm scripts/generate-native-exports.ts
 *
 * This script:
 * 1. Parses the built d.ts files to get actual exports (run after yarn typegen)
 * 2. Filters out components that don't work on React Native
 * 3. Generates src/native/index.ts with explicit re-exports
 *
 * Run this when:
 * - Adding new components to core or webgpu
 * - Changing which components are excluded for native
 */

import * as fs from 'fs'
import * as path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const ROOT = path.join(__dirname, '..')
const NATIVE_INDEX = path.join(ROOT, 'src/native/index.ts')
const WEBGPU_DTS = path.join(ROOT, 'dist/webgpu/index.d.ts')

//* Exclusion Configuration ==============================
// Components that don't work on React Native
// Format: component name -> reason for exclusion

const NATIVE_EXCLUSIONS: Record<string, string> = {
  // DOM-dependent components
  Html: 'requires DOM which is not available on React Native',

  // Controls requiring DOM pointer/keyboard events
  ArcballControls: 'requires DOM pointer events not available on React Native',
  DragControls: 'requires DOM pointer events not available on React Native',
  FirstPersonControls: 'requires DOM pointer events not available on React Native',
  FlyControls: 'requires DOM pointer events not available on React Native',
  KeyboardControls: 'requires keyboard events not available on React Native',
  MapControls: 'requires DOM pointer events not available on React Native',
  OrbitControls: 'requires DOM pointer events not available on React Native',
  PointerLockControls: 'requires Pointer Lock API not available on React Native',
  ScrollControls: 'requires DOM scroll events not available on React Native',
  TrackballControls: 'requires DOM pointer events not available on React Native',

  // Complex effects not yet supported on native
  Caustics: 'not yet supported on React Native',
}

//* Parse Exports from d.ts ==============================

function parseExportsFromDts(filePath: string): { values: string[]; types: string[] } {
  if (!fs.existsSync(filePath)) {
    throw new Error(`d.ts file not found: ${filePath}\nRun 'yarn typegen' first.`)
  }

  const content = fs.readFileSync(filePath, 'utf-8')
  const values: string[] = []
  const types: string[] = []

  // Match: export { Name1, Name2, ... };
  const valueExportMatch = content.match(/^export\s*\{([^}]+)\};/m)
  if (valueExportMatch) {
    const exports = valueExportMatch[1]
      .split(',')
      .map((e) => e.trim())
      .filter((e) => e.length > 0)
      .map((e) => {
        // Handle "Foo$1 as Bar" -> "Bar"
        const asMatch = e.match(/\w+\s+as\s+(\w+)/)
        return asMatch ? asMatch[1] : e
      })
    values.push(...exports)
  }

  // Match: export type { Type1, Type2, ... };
  const typeExportMatch = content.match(/^export\s+type\s*\{([^}]+)\};/m)
  if (typeExportMatch) {
    const exports = typeExportMatch[1]
      .split(',')
      .map((e) => e.trim())
      .filter((e) => e.length > 0)
    types.push(...exports)
  }

  return { values, types }
}

//* Code Generation ==============================

function generateNativeIndex(values: string[], types: string[]): string {
  // Filter exclusions
  const excludedNames = Object.keys(NATIVE_EXCLUSIONS)

  const includedValues = values.filter((v) => !excludedNames.includes(v)).sort()
  const includedTypes = types.filter((t) => !excludedNames.includes(t.replace(/Props$/, ''))).sort()

  // Also filter Props types for excluded components
  const excludedPropsTypes = excludedNames.map((n) => `${n}Props`)
  const filteredTypes = includedTypes.filter((t) => !excludedPropsTypes.includes(t))

  // Generate the file
  const lines: string[] = [
    `//* Native Entry Point ==============================`,
    `// AUTO-GENERATED by scripts/generate-native-exports.ts`,
    `// Do not edit manually - run: yarn generate:native`,
    `//`,
    `// This entry exports drei components for React Native with WebGPU aliasing.`,
    `// When built, all #three imports resolve to 'three/webgpu'.`,
    `//`,
    `// Excluded components (${excludedNames.length}):`,
  ]

  // Add exclusion documentation
  for (const [name, reason] of Object.entries(NATIVE_EXCLUSIONS)) {
    lines.push(`//   - ${name}: ${reason}`)
  }

  lines.push(`//`)
  lines.push(`// Usage: import { Box, MeshDistortMaterial } from '@react-three/drei/native'`)
  lines.push(``)

  // Generate value exports
  lines.push(`//* Value exports ==============================`)
  lines.push(`export {`)

  // Format nicely with multiple per line
  const chunkSize = 5
  for (let i = 0; i < includedValues.length; i += chunkSize) {
    const chunk = includedValues.slice(i, i + chunkSize)
    const isLast = i + chunkSize >= includedValues.length
    lines.push(`  ${chunk.join(', ')}${isLast ? '' : ','}`)
  }

  lines.push(`} from '../webgpu'`)
  lines.push(``)

  // Generate type exports
  if (filteredTypes.length > 0) {
    lines.push(`//* Type exports ==============================`)
    lines.push(`export type {`)

    for (let i = 0; i < filteredTypes.length; i += chunkSize) {
      const chunk = filteredTypes.slice(i, i + chunkSize)
      const isLast = i + chunkSize >= filteredTypes.length
      lines.push(`  ${chunk.join(', ')}${isLast ? '' : ','}`)
    }

    lines.push(`} from '../webgpu'`)
    lines.push(``)
  }

  return lines.join('\n')
}

//* Main ==============================

function main() {
  console.log('üîç Parsing exports from dist/webgpu/index.d.ts...')

  const { values, types } = parseExportsFromDts(WEBGPU_DTS)
  console.log(`   Found ${values.length} value exports`)
  console.log(`   Found ${types.length} type exports`)

  // Count exclusions that actually exist
  const excludedNames = Object.keys(NATIVE_EXCLUSIONS)
  const actualExclusions = excludedNames.filter((n) => values.includes(n))

  console.log(`\nüìù Generating native/index.ts...`)
  const content = generateNativeIndex(values, types)

  fs.writeFileSync(NATIVE_INDEX, content, 'utf-8')
  console.log(`‚úÖ Generated ${NATIVE_INDEX}`)

  // Summary
  const includedCount = values.length - actualExclusions.length
  console.log(`\nüìä Summary:`)
  console.log(
    `   Value exports: ${values.length} total, ${includedCount} included, ${actualExclusions.length} excluded`
  )
  console.log(`   Type exports: ${types.length} total`)

  // List what was excluded
  console.log(`\nüö´ Excluded components:`)
  for (const name of actualExclusions) {
    console.log(`   - ${name}: ${NATIVE_EXCLUSIONS[name]}`)
  }

  // Warn about exclusions that don't exist
  const missingExclusions = excludedNames.filter((n) => !values.includes(n))
  if (missingExclusions.length > 0) {
    console.log(`\n‚ö†Ô∏è  Warning: These exclusions don't match any exports:`)
    for (const name of missingExclusions) {
      console.log(`   - ${name}`)
    }
  }
}

main()
