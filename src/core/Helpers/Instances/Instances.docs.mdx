{/* AUTO:badges */}

<Grid cols={4}>
  <li>
    <Codesandbox id="h8o2d" />
  </li>
  <li>
    <Codesandbox id="i6t0j" />
  </li>
</Grid>

{/* AUTO:description */}

{/* AUTO:example */}

## Nested Instances

You can nest Instances and use relative coordinates!

```jsx
<group position={[1, 2, 3]} rotation={[Math.PI / 2, 0, 0]}>
  <Instance />
</group>
```

Instances can also receive non-instanced objects, for instance annotations!

```jsx
<Instance>
  <Html>hello from the dom</Html>
</Instance>
```

## Events

You can define events on them!

```jsx
<Instance onClick={...} onPointerOver={...} />
```

## createInstances for Nested Graphs

If you need nested, multiple instances in the same parent graph, it would normally not work because an `<Instance>` is directly paired to its nearest `<Instances>` provider. You can use the global `createInstances` helper for such cases, it creates dedicated instances-instance pairs.

```jsx
const [CubeInstances, Cube] = createInstances()
const [SphereInstances, Sphere] = createInstances()

function App() {
  return (
    <>
      <CubeInstances>
        <boxGeometry />
        <meshStandardMaterial />
        <SphereInstances>
          <sphereGeometry />
          <meshLambertMaterial />
          <Cube position={[1, 2, 3]} />
          <Sphere position={[4, 5, 6]} />
        </SphereInstances>
      </CubeInstances>
    </>
  )
}
```

## InstancedAttribute

If your custom materials need instanced attributes you can create them using the `InstancedAttribute` component. It will automatically create the buffer and update it when the component changes.

```jsx
<Instances ref={ref} limit={20}>
  <boxGeometry />
  <someSpecialMaterial />
  <InstancedAttribute name="foo" defaultValue={1} />
  <Instance position={[-1.2, 0, 0]} foo={10} />
</Instances>
```

```glsl
# vertex
attribute float foo;
varying float vFoo;
void main() {
  ...
  vFoo = foo;

# fragment
varying float vFoo;
void main() {
  ...
```

> Note: While creating instances declaratively keeps all the power of components with reduced draw calls, it comes at the cost of CPU overhead. For cases like foliage where you want no CPU overhead with thousands of intances you should use THREE.InstancedMesh such as in this [example](https://codesandbox.io/s/grass-shader-5xho4?file=/src/Grass.js).

## Typed Instances

When you need to declare custom attributes for your instances, you can use the `createInstances` helper to type its attributes.

```tsx
interface SphereAttributes {
  myCustomAttribute: number
}

const [SphereInstances, Sphere] = createInstances<SphereAttributes>()

function App() {
  return (
    <SphereInstances>
      <InstancedAttribute name="myCustomAttribute" defaultValue={1} />
      <sphereGeometry />
      <shaderMaterial
        vertexShader={`
          attribute float myCustomAttribute;
          void main() { ... }
        `}
      />
      <Sphere
        position={[4, 5, 6]}
        myCustomAttribute={1} // typed
      />
    </SphereInstances>
  )
}
```

