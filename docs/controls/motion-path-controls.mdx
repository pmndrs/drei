---
title: MotionPathControls
sourcecode: src/core/Controls/MotionPathControls/MotionPathControls.tsx
---

[![](https://img.shields.io/badge/-storybook-%23ff69b4)](https://drei.pmnd.rs/?path=/story/controls-motionpathcontrols--motionpathcontrols-st)

<Grid cols={4}>
  <li>
    <Codesandbox id="2y73c6" />
  </li>
</Grid>

Motion path controls, it takes a path of bezier curves or catmull-rom curves as input
and animates the passed `object` along that path. It can be configured to look upon an
external object for staging or presentation purposes by adding a `focus` property (ref).

You can exert full control with the `useMotion` hook, it allows you to define the current
position along the path for instance, or define your own lookAt.

### Declarative curves

```jsx
<MotionPathControls offset={0} focus={poiRef} damping={0.2}>
  <cubicBezierCurve3 v0={[-5, -5, 0]} v1={[-10, 0, 0]} v2={[0, 3, 0]} v3={[6, 3, 0]} />
  <cubicBezierCurve3 v0={[6, 3, 0]} v1={[10, 5, 5]} v2={[5, 5, 5]} v3={[5, 5, 5]} />
</MotionPathControls>
```

### With useMotion hook for full control

```jsx
function Loop() {
  const motion = useMotion()
  useFrame((state, delta) => {
    motion.current += delta
    motion.object.current.lookAt(motion.next)
  })
}
```

You can also use imperative curves:

```jsx
<MotionPathControls
  offset={0}
  focus={poi}
  damping={0.2}
  curves={[
    new THREE.CubicBezierCurve3(
      new THREE.Vector3(-5, -5, 0),
      new THREE.Vector3(-10, 0, 0),
      new THREE.Vector3(0, 3, 0),
      new THREE.Vector3(6, 3, 0)
    ),
  ]}
/>
```

